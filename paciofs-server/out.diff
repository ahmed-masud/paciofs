diff --git a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/Bitcoind.java b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/Bitcoind.java
index 127a626..10c4a1b 100644
--- a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/Bitcoind.java
+++ b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/Bitcoind.java
@@ -136,6 +136,9 @@ public class Bitcoind extends AbstractClusterDomainEventListener {
         LOG.debug(Markers.EXCEPTION, "Adding node failed", e);
       }
     }
+
+    // have MultiChain measure latency and backlog
+    this.client.ping();
   }
 
   private void removeNode(Member member) {
@@ -152,5 +155,8 @@ public class Bitcoind extends AbstractClusterDomainEventListener {
         LOG.debug(Markers.EXCEPTION, "Removing node failed", e);
       }
     }
+
+    // have MultiChain measure latency and backlog
+    this.client.ping();
   }
 }
diff --git a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MapWrapper.java b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MapWrapper.java
index 9bac2f8..ae88c51 100644
--- a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MapWrapper.java
+++ b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MapWrapper.java
@@ -7,6 +7,7 @@
 
 package de.zib.paciofs.blockchain.multichain;
 
+import java.io.Serializable;
 import java.math.BigDecimal;
 import java.util.Date;
 import java.util.Map;
@@ -16,7 +17,7 @@ import wf.bitcoin.krotjson.HexCoder;
 /**
  * Unfortunately, wf.bitcoin.javabitcoinrpcclient.MapWrapper is package-private.
  */
-public class MapWrapper implements MapWrapperType {
+public class MapWrapper implements MapWrapperType, Serializable {
   private static final long SECONDS_TO_MILLISECONDS = 1000L;
 
   private final Map<String, ?> map;
diff --git a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainClient.java b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainClient.java
index 3f67bb5..c0dca12 100644
--- a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainClient.java
+++ b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainClient.java
@@ -9,8 +9,9 @@ package de.zib.paciofs.blockchain.multichain;
 
 import com.typesafe.config.Config;
 import de.zib.paciofs.logging.Markers;
+import java.net.InetAddress;
 import java.net.MalformedURLException;
-import java.net.URL;
+import java.net.UnknownHostException;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -33,6 +34,9 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
 
   private final MultiChaind multiChaind;
 
+  private String localhostName;
+  private String localhostAddress;
+
   private LifecyclePhase lifecyclePhase;
 
   private final Object lifecyclePhaseTransition;
@@ -44,10 +48,6 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
    * @throws MalformedURLException if the URL constructed from the configuration is invalid
    */
   public MultiChainClient(Config config) throws MalformedURLException {
-    super(new URL("http://" + config.getString(MultiChainOptions.RPC_USER_KEY) + ":"
-        + config.getString(MultiChainOptions.RPC_PASSWORD_KEY) + "@"
-        + config.getString(MultiChainOptions.RPC_CONNECT_KEY) + ":"
-        + config.getInt(MultiChainOptions.RPC_PORT_KEY)));
     this.config = config;
 
     // start MultiChain locally if localhost is the target connect
@@ -55,11 +55,28 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
       this.multiChaind = new MultiChaind(this.config);
       this.lifecyclePhase = LifecyclePhase.STOPPED;
       this.lifecyclePhaseTransition = new Object();
+
+      // we need to start multichaind first and obtain the user info from it
     } else {
       // assume all is well if we connect to a remote MultiChain
       this.multiChaind = null;
       this.lifecyclePhase = LifecyclePhase.RUNNING;
       this.lifecyclePhaseTransition = null;
+
+      // set target URL to configured values
+      this.setUrl(this.getProtocol(), config.getString(MultiChainOptions.RPC_USER_KEY),
+          config.getString(MultiChainOptions.RPC_PASSWORD_KEY),
+          config.getString(MultiChainOptions.RPC_CONNECT_KEY),
+          config.getInt(MultiChainOptions.RPC_PORT_KEY));
+    }
+
+    try {
+      final InetAddress localhost = InetAddress.getLocalHost();
+      this.localhostName = localhost.getHostName();
+      this.localhostAddress = localhost.getHostAddress();
+    } catch (UnknownHostException e) {
+      LOG.warn("Could not get localhost: {}" + e.getMessage());
+      LOG.debug(Markers.EXCEPTION, "Could not get localhost", e);
     }
   }
 
@@ -84,7 +101,7 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
   public Object query(String method, Object... o) throws GenericRpcException {
     this.ensureRunning();
 
-    // logging is potentially expensive here
+    // TODO surround with try-catch and maybe switch to FAILED if we get errors
     if (LOG.isTraceEnabled()) {
       LOG.trace("Query: {}{}", method, o);
       final Object result = super.query(method, o);
@@ -92,12 +109,16 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
       return result;
     }
 
-    // TODO surround with try-catch and maybe switch to FAILED if we get errors
     return super.query(method, o);
   }
 
   @Override
   public void addNode(String node, String command) throws GenericRpcException {
+    if (node.equals(this.localhostName) || node.equals(this.localhostAddress)) {
+      LOG.debug("Not {}'ing {} because it is this node", command, node);
+      return;
+    }
+
     final String nodeWithPort = node + ":" + this.config.getInt(MultiChainOptions.PORT_KEY);
 
     // https://www.multichain.com/developers/json-rpc-api/
@@ -130,6 +151,10 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
     }
   }
 
+  private String getProtocol() {
+    return this.config.hasPath(MultiChainOptions.RPC_SSL) ? "https" : "http";
+  }
+
   // manages the transition from STOPPED -> STARTING -> RUNNING in a blocking fashion
   private void ensureRunning() {
     if (this.lifecyclePhase == LifecyclePhase.RUNNING) {
@@ -146,6 +171,13 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
         // wait until the service is up
         this.multiChaind.start();
 
+        // now we have all the information of where to direct our RPC calls
+        this.setUrl(this.getProtocol(),
+            this.multiChaind.getMultiChainConf().getString(MultiChainOptions.RPC_USER_KEY),
+            this.multiChaind.getMultiChainConf().getString(MultiChainOptions.RPC_PASSWORD_KEY),
+            config.getString(MultiChainOptions.RPC_CONNECT_KEY),
+            config.getInt(MultiChainOptions.RPC_PORT_KEY));
+
         // wait at most backoff * (2^maxRetries - 1) milliseconds
         // e.g. 50 * (2^10 -1) = 51150 milliseconds
         long backoff = this.config.getLong(MultiChainOptions.BACKOFF_MILLISECONDS);
@@ -162,8 +194,6 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
             break;
           } catch (BitcoinRPCException rpcException) {
             final BitcoinRPCError rpcError = rpcException.getRPCError();
-
-            // check what has gone wrong
             if (rpcError != null && rpcError.getCode() == RPC_IN_WARMUP) {
               // keep waiting, multichaind is at work and will be with us soon
               LOG.debug(
@@ -174,9 +204,9 @@ public class MultiChainClient extends MultiChainJsonRpcClient {
               this.forcedLifecyclePhaseTransition(LifecyclePhase.FAILED);
               throw new RuntimeException("multichaind stopped running");
             } else {
-              // we do not know yet what is wrong
-              LOG.debug("Waiting {} ms, multichaind has not started yet ({})", backoff,
-                  rpcException.getMessage());
+              // we do not know yet what is wrong, multichaind does not react to RPC calls
+              LOG.debug("Waiting {} ms, multichaind has not started yet ({}: {})", backoff,
+                  rpcException.getResponseCode(), rpcException.getMessage());
               LOG.debug(Markers.EXCEPTION, "multichaind has not started yet", rpcException);
             }
 
diff --git a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainJsonRpcClient.java b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainJsonRpcClient.java
index 7f5be42..f9b128e 100644
--- a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainJsonRpcClient.java
+++ b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainJsonRpcClient.java
@@ -7,19 +7,56 @@
 
 package de.zib.paciofs.blockchain.multichain;
 
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.io.Serializable;
 import java.math.BigDecimal;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.net.URL;
+import java.util.Arrays;
 import java.util.Map;
+import javax.net.ssl.HttpsURLConnection;
 import wf.bitcoin.javabitcoindrpcclient.BitcoinJSONRPCClient;
+import wf.bitcoin.javabitcoindrpcclient.BitcoinRPCException;
+import wf.bitcoin.javabitcoindrpcclient.GenericRpcException;
+import wf.bitcoin.krotjson.Base64Coder;
 
 /**
  * Exposes some of MultiChain's custom commands.
  * @see <a href="https://www.multichain.com/developers/json-rpc-api/">JSON RPC API</a>
  */
 public class MultiChainJsonRpcClient extends BitcoinJSONRPCClient implements MultiChaindRpcClient {
-  public MultiChainJsonRpcClient(URL url) {
-    super(url);
+  private static final int STREAM_BUFFER_SIZE = 1024;
+
+  private URL url;
+
+  private String auth;
+
+  public MultiChainJsonRpcClient() {
+    // always against testnet, because we never use this URL
+    super(true);
+  }
+
+  // constructs the target URL and authentication information
+  protected void setUrl(String protocol, String user, String password, String host, int port) {
+    try {
+      this.url = new URI(protocol, null, host, port, null, null, null).toURL();
+    } catch (MalformedURLException | URISyntaxException ex) {
+      throw new IllegalArgumentException(ex);
+    }
+
+    String userInfo = user;
+    if (userInfo != null && password != null) {
+      userInfo += ":" + password;
+    }
+
+    this.auth = userInfo == null
+        ? null
+        : String.valueOf(Base64Coder.encode(userInfo.getBytes(QUERY_CHARSET)));
   }
 
   @Override
@@ -27,7 +64,7 @@ public class MultiChainJsonRpcClient extends BitcoinJSONRPCClient implements Mul
     return new InfoMapWrapper((Map<String, ?>) this.query("getinfo"));
   }
 
-  private class InfoMapWrapper extends MapWrapper implements Info, Serializable {
+  private static class InfoMapWrapper extends MapWrapper implements Info, Serializable {
     private static final long serialVersionUID = 2509558745656609453L;
 
     private InfoMapWrapper(Map<String, ?> map) {
@@ -174,4 +211,66 @@ public class MultiChainJsonRpcClient extends BitcoinJSONRPCClient implements Mul
       return this.mapStr("errors");
     }
   }
+
+  /*
+   * from the 1.1.0 release commit
+   * https://github.com/Polve/bitcoin-rpc-client/blob/a0005e146e863b4cb2610fb0257da25da0b70a11/src/main/java/wf/bitcoin/javabitcoindrpcclient/BitcoinJSONRPCClient.java#L209
+   * fully override so we can add our authentication after (and not during) instantiation
+   */
+
+  @Override
+  public Object query(String method, Object... o) throws GenericRpcException {
+    try {
+      final HttpURLConnection connection = (HttpURLConnection) this.url.openConnection();
+      connection.setDoOutput(true);
+      connection.setDoInput(true);
+
+      if (connection instanceof HttpsURLConnection) {
+        if (this.getHostnameVerifier() != null) {
+          ((HttpsURLConnection) connection).setHostnameVerifier(this.getHostnameVerifier());
+        }
+        if (this.getSslSocketFactory() != null) {
+          ((HttpsURLConnection) connection).setSSLSocketFactory(this.getSslSocketFactory());
+        }
+      }
+      connection.setRequestProperty("Authorization", "Basic " + this.auth);
+
+      final byte[] r = this.prepareRequest(method, o);
+      connection.getOutputStream().write(r);
+      connection.getOutputStream().close();
+
+      final int responseCode = connection.getResponseCode();
+      if (responseCode != HttpURLConnection.HTTP_OK) {
+        final InputStream errorStream = connection.getErrorStream();
+        throw new BitcoinRPCException(method, Arrays.deepToString(o), responseCode,
+            connection.getResponseMessage(),
+            errorStream == null ? null : new String(loadStream(errorStream, true), QUERY_CHARSET));
+      }
+
+      return this.loadResponse(connection.getInputStream(), "1", true);
+    } catch (IOException ex) {
+      throw new BitcoinRPCException(method, Arrays.deepToString(o), ex);
+    }
+  }
+
+  private static byte[] loadStream(InputStream in, boolean close) throws IOException {
+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    final byte[] buffer = new byte[STREAM_BUFFER_SIZE];
+    for (;;) {
+      final int read = in.read(buffer);
+      if (read == -1) {
+        break;
+      } else if (read == 0) {
+        throw new IOException("Read timed out");
+      }
+
+      baos.write(buffer, 0, read);
+    }
+
+    if (close) {
+      in.close();
+    }
+
+    return baos.toByteArray();
+  }
 }
diff --git a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainOptions.java b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainOptions.java
index 5f897c1..c7c32e2 100644
--- a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainOptions.java
+++ b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChainOptions.java
@@ -25,6 +25,7 @@ public class MultiChainOptions {
   public static final String RPC_PORT_KEY = "rpcport";
   public static final String RPC_USER_KEY = "rpcuser";
   public static final String RPC_PASSWORD_KEY = "rpcpassword";
+  public static final String RPC_SSL = "rpcssl";
 
   public static final String UTIL_OPTIONS_KEY = "multichain.multichain-util.options";
 
diff --git a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChaind.java b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChaind.java
index ff1b239..417be6b 100644
--- a/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChaind.java
+++ b/paciofs-server/src/main/java/de/zib/paciofs/blockchain/multichain/MultiChaind.java
@@ -9,12 +9,15 @@ package de.zib.paciofs.blockchain.multichain;
 
 import ch.qos.logback.classic.Level;
 import com.typesafe.config.Config;
+import com.typesafe.config.ConfigFactory;
 import com.typesafe.config.ConfigValue;
 import de.zib.paciofs.logging.Markers;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.function.Consumer;
@@ -33,6 +36,10 @@ import sun.misc.Signal;
 public class MultiChaind {
   private static final String OPTION_DAEMON = "daemon";
   private static final String OPTION_DATADIR = "datadir";
+  private static final String OPTION_RPCALLOW = "rpcallow";
+  private static final String OPTION_RPCUSER = "rpcuser";
+  private static final String OPTION_RPCPASSWORD = "rpcpassword";
+  private static final String OPTION_SERVER = "server";
 
   private static final Logger LOG = LoggerFactory.getLogger(MultiChaind.class);
 
@@ -42,6 +49,8 @@ public class MultiChaind {
 
   private final Config config;
 
+  private Config multiChainConf;
+
   private ExecuteWatchdog watchdog;
   private DefaultExecuteResultHandler executeResultHandler;
 
@@ -63,37 +72,15 @@ public class MultiChaind {
     cmd.addArgument(this.config.getString(MultiChainOptions.BLOCKCHAIN_NAME_KEY));
     cmd.addArgument(this.config.getString(MultiChainOptions.PROTOCOL_VERSION_KEY));
 
-    // holds substitutions for the command line arguments we are building
-    final Map<String, Object> substitutions = new HashMap<>();
-
-    // build the remaining options
-    final Config options = this.config.getConfig(MultiChainOptions.DAEMON_OPTIONS_KEY);
-    for (Map.Entry<String, ConfigValue> entry : options.entrySet()) {
-      final String key = entry.getKey();
-
-      String value = entry.getValue().unwrapped().toString();
-
-      switch (key) {
-        case OPTION_DAEMON:
-          // we are running multichaind in the background anyway
-          LOG.debug("Ignoring -{} multichaind option", key);
-          break;
-        case OPTION_DATADIR:
-          // add substitution and replace value with placeholder for
-          // substitution
-          substitutions.put(key, new File(value));
-          value = buildCommandLineSubstitution(key);
-          // fall-through
-        default:
-          cmd.addArgument(buildCommandLineOption(key, value));
-          break;
-      }
-    }
-    cmd.setSubstitutionMap(substitutions);
+    // multichaind-specific options
+    this.addMultiChaindOptions(cmd);
 
     // make sure all directories and configuration files exist
     this.initializeBlockchain();
 
+    // read multichain.conf that was generated for this chain
+    this.readMultiChainConf();
+
     // the executor we use to run multichaind in
     final Executor executor = new DefaultExecutor() {
       @Override
@@ -167,6 +154,10 @@ public class MultiChaind {
     return this.watchdog != null && this.watchdog.isWatching();
   }
 
+  public Config getMultiChainConf() {
+    return this.multiChainConf;
+  }
+
   private void initializeBlockchain() {
     final Config options = this.config.getConfig(MultiChainOptions.UTIL_OPTIONS_KEY);
 
@@ -192,23 +183,8 @@ public class MultiChaind {
       cmd.addArgument(blockchainName);
       cmd.addArgument(this.config.getString(MultiChainOptions.PROTOCOL_VERSION_KEY));
 
-      // build remaining options like above
-      final Map<String, Object> substitutions = new HashMap<>();
-      for (Map.Entry<String, ConfigValue> entry : options.entrySet()) {
-        final String key = entry.getKey();
-        String value = entry.getValue().unwrapped().toString();
-
-        switch (key) {
-          case OPTION_DATADIR:
-            substitutions.put(key, datadir);
-            value = buildCommandLineSubstitution(key);
-            // fall-through
-          default:
-            cmd.addArgument(buildCommandLineOption(key, value));
-            break;
-        }
-      }
-      cmd.setSubstitutionMap(substitutions);
+      // multichain-util-specific options
+      this.addMultiChainUtilOptions(cmd);
 
       final Executor executor = new DefaultExecutor() {
         @Override
@@ -228,6 +204,88 @@ public class MultiChaind {
     }
   }
 
+  private void readMultiChainConf() {
+    final Config options = this.config.getConfig(MultiChainOptions.UTIL_OPTIONS_KEY);
+    final File blockchainDir = new File(options.getString(OPTION_DATADIR),
+        this.config.getString(MultiChainOptions.BLOCKCHAIN_NAME_KEY));
+    this.multiChainConf = ConfigFactory.parseFile(new File(blockchainDir, "multichain.conf"));
+  }
+
+  private void addMultiChaindOptions(CommandLine cmd) {
+    // holds substitutions for the command line arguments we are building
+    final Map<String, Object> substitutions = new HashMap<>();
+
+    // build the remaining options
+    final Config options = this.config.getConfig(MultiChainOptions.DAEMON_OPTIONS_KEY);
+    for (Map.Entry<String, ConfigValue> entry : options.entrySet()) {
+      final String key = entry.getKey();
+
+      String value = entry.getValue().unwrapped().toString();
+
+      switch (key) {
+        case OPTION_DAEMON:
+          // we are running multichaind in the background anyway, fall-through
+        case OPTION_RPCALLOW:
+          // we only allow localhost, fall-through
+        case OPTION_RPCUSER:
+          // we use multichaind generated rpcuser, fall-through
+        case OPTION_RPCPASSWORD:
+          // we use multichaind generated rpcpassword, fall-through
+        case OPTION_SERVER:
+          // we add the server option ourselves
+          LOG.debug("Ignoring -{} multichaind option", key);
+          break;
+        case OPTION_DATADIR:
+          // add substitution and replace value with placeholder for
+          // substitution
+          substitutions.put(key, new File(value));
+          value = buildCommandLineSubstitution(key);
+          // fall-through
+        default:
+          cmd.addArgument(buildCommandLineOption(key, value));
+          break;
+      }
+    }
+    cmd.setSubstitutionMap(substitutions);
+
+    // serve JSON RPCs
+    cmd.addArgument(buildCommandLineOption(OPTION_SERVER, ""));
+
+    // only allow RPC commands from our host
+    cmd.addArgument(buildCommandLineOption(OPTION_RPCALLOW, "localhost"));
+    try {
+      final InetAddress localHost = InetAddress.getLocalHost();
+      cmd.addArgument(buildCommandLineOption(OPTION_RPCALLOW, localHost.getHostName()));
+      cmd.addArgument(buildCommandLineOption(OPTION_RPCALLOW, localHost.getHostAddress()));
+    } catch (UnknownHostException e) {
+      LOG.warn("Could not add all -{} options: {}", OPTION_RPCALLOW, e.getMessage());
+      LOG.debug(Markers.EXCEPTION, "Could not get localhost", e);
+    }
+  }
+
+  private void addMultiChainUtilOptions(CommandLine cmd) {
+    final Config options = this.config.getConfig(MultiChainOptions.UTIL_OPTIONS_KEY);
+    final File datadir = new File(options.getString(OPTION_DATADIR));
+
+    // build remaining options like above
+    final Map<String, Object> substitutions = new HashMap<>();
+    for (Map.Entry<String, ConfigValue> entry : options.entrySet()) {
+      final String key = entry.getKey();
+      String value = entry.getValue().unwrapped().toString();
+
+      switch (key) {
+        case OPTION_DATADIR:
+          substitutions.put(key, datadir);
+          value = buildCommandLineSubstitution(key);
+          // fall-through
+        default:
+          cmd.addArgument(buildCommandLineOption(key, value));
+          break;
+      }
+    }
+    cmd.setSubstitutionMap(substitutions);
+  }
+
   private static String buildCommandLineOption(String option, String argument) {
     return "-" + option + (!"".equals(argument) ? "=" + argument : "");
   }
diff --git a/paciofs-server/src/main/resources/application.conf b/paciofs-server/src/main/resources/application.conf
index e012bc9..7171c37 100644
--- a/paciofs-server/src/main/resources/application.conf
+++ b/paciofs-server/src/main/resources/application.conf
@@ -11,10 +11,10 @@ paciofs {
   # set to DENY to exclude their output from the logs
   logging.markers {
     # used for printing configurations
-    configuration = DENY
+    configuration = "DENY"
 
     # used for printing exceptions (usually in DEBUG or TRACE level)
-    exception = DENY
+    exception = "DENY"
   }
 
   bitcoind-client {
@@ -27,6 +27,7 @@ paciofs {
     rpcport = 8332
     rpcuser = "rpcuser"
     rpcpassword = "rpcpassword"
+    # rpcssl = ""
 
     # used to start MultiChain if paciofs.bitcoind-client.rpcconnect = "localhost"
     multichain {
@@ -93,26 +94,21 @@ paciofs {
 
           # RPC server options #
 
-          # Accept command line and JSON-RPC commands
-          server = ""
-
-          # Username for JSON-RPC connections
-          rpcuser = ${paciofs.bitcoind-client.rpcuser}
-
-          # Password for JSON-RPC connections
-          rpcpassword = ${paciofs.bitcoind-client.rpcpassword}
-
           # Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)
           rpcport = ${paciofs.bitcoind-client.rpcport}
+
+          # Use OpenSSL (https) for JSON-RPC connections
+          rpcssl = ${?paciofs.bitcoind-client.rpcssl}
         }
       }
 
       # passed to multichain-util, see multichain-util -?
       multichain-util.options {
+        # datadir is the only option related to the setup
         datadir = ${paciofs.bitcoind-client.multichain.multichaind.options.datadir}
-        rpcuser = ${paciofs.bitcoind-client.multichain.multichaind.options.rpcuser}
-        rpcpassword = ${paciofs.bitcoind-client.multichain.multichaind.options.rpcpassword}
-        walletdbversion = ${paciofs.bitcoind-client.multichain.multichaind.options.walletdbversion}
+
+        # all other parameters are blockchain parameters:
+        # https://www.multichain.com/developers/blockchain-parameters/
       }
     }
   }
diff --git a/paciofs-server/src/main/resources/logback.xml b/paciofs-server/src/main/resources/logback.xml
index db91dc6..1269a26 100644
--- a/paciofs-server/src/main/resources/logback.xml
+++ b/paciofs-server/src/main/resources/logback.xml
@@ -1,4 +1,4 @@
-<configuration>
+<configuration debug="false">
     <!-- log levels -->
     <define name="log-level" class="de.zib.paciofs.logging.LogbackPropertyDefiners$ConfigVarWithDefaultValue">
         <var>log-level</var>
